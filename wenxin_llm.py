#!/usr/bin/env python
# coding: utf-8

"""Wrapper around WENXINWORKSHOP APIs.

TODO: Add access_token refresh logic.
"""
import logging
from typing import Any, Dict, List, Optional

from pydantic import Extra, root_validator

from langchain.llms.base import LLM
from langchain.llms.utils import enforce_stop_tokens
from langchain.utils import get_from_dict_or_env

import requests

logger = logging.getLogger(__name__)

class Wenxin(LLM):
    """Wrapper around Baidu Wenxin large language models.

    To use, you should set environment variable: 
        ``WENXIN_ACCESS_TOKEN``: Wenxin access token.
        ``WENXIN_REFRESH_KEY``: Wenxin refresh key.(optional, if not set, access token will be expired after 30 days)

    Example:
        .. code-block:: python

            from langchain.llms import Wenxin
            wenxin = Wenxin(model="wenxinworkshop", wenxin_access_token="my-access-token")
    """
    client: Any  #: :meta private:
    model: Optional[str] = "wenxinworkshop"
    """Model name to use."""

    max_message_length: Optional[int] = 2000
    """Maximum length of message to send to Wenxin."""

    wenxin_access_token: Optional[str] = None
    """Wenxin access token."""

    wenxin_refresh_key: Optional[str] = None
    """Wenxin refresh key."""

    class Config:
        """Configuration for this pydantic object."""

        extra = Extra.forbid

    @root_validator(allow_reuse=True)
    def validate_environment(cls, values: Dict) -> Dict:
        """Validate that api key and python package exists in environment."""
        wenxin_access_token = get_from_dict_or_env(
            values, "wenxin_access_token", "WENXIN_ACCESS_TOKEN"
        )
        wenxin_refresh_key = get_from_dict_or_env(
            values, "wenxin_refresh_key", "WENXIN_REFRESH_KEY", default=""
        )
        values["client"] = WenxinClient(wenxin_access_token, wenxin_refresh_key)
        return values

    @property
    def _default_params(self) -> Dict[str, Any]:
        """Get the default parameters for calling Wenxin API."""
        return {}

    @property
    def _identifying_params(self) -> Dict[str, Any]:
        """Get the identifying parameters."""
        return {**{"model": self.model}, **self._default_params}

    @property
    def _llm_type(self) -> str:
        """Return type of llm."""
        return "wenxin"

    def _call(self, prompt: str, stop: Optional[List[str]] = None) -> str:
        """Call out to Wenxin's generate endpoint.

        Args:
            prompt: The prompt to pass into the model.

        Returns:
            The string generated by the model.

        Example:
            .. code-block:: python

                response = wenxin("Tell me a joke.")
        """
        params = self._default_params

        if len(prompt) > self.max_message_length:
            raise ValueError(
                f"Message length {len(prompt)} is longer than max length {self.max_message_length}"
            )

        response = self.client.generate(model=self.model, prompt=prompt, **params)
        return response["result"]

class WenxinClient(object):
    WENXIN_COMPLETION_URL = "https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/completions"
    WENXIN_TIMEOUT = 115

    def __init__(self, wenxin_access_token: str, wenxin_refresh_key: str):
        self.wenxin_access_token = wenxin_access_token
        self.wenxin_refresh_key = wenxin_refresh_key

    def generate(self, model: str, prompt: str, **params):
        """Call out to Wenxin's generate endpoint.

        Args:
            model: The model to use.
            prompt: The prompt to pass into the model.
            **params: Additional parameters to pass to the API.
        
        Returns:
            The string generated by the model.
        """
        r = requests.post(
            url=self.WENXIN_COMPLETION_URL,
            params={"access_token": self.wenxin_access_token},
            json=dict(messages=[dict(role="user", content=prompt)]),
            timeout=self.WENXIN_TIMEOUT,
        )
        r.raise_for_status()
        response = r.json()
        error_code = response.get("error_code", 0)
        if error_code != 0:
            error_msg = response.get("error_msg", "Unknown error")
            raise Exception(f"call wenxin failed, error_code: {error_code}, error_msg: {error_msg}")
        
        return response


if __name__ == "__main__":
    wenxin = Wenxin()
    print(wenxin("你是谁？"))
